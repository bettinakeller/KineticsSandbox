#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Sat May 25 10:22:46 2024This tests the EM integgrator implemented in implemented in integratos/D1_stochastic.py@author: bettina"""#-----------------------------------------#   I M P O R T S #-----------------------------------------import sysimport os# Get the absolute path of the parent directoryparent_dir = os.path.abspath("../../")# Append the parent directory to sys.path if it is not already includedif parent_dir not in sys.path:    sys.path.append(parent_dir)print("---------------------------------------")print("System path:")print(sys.path)    import matplotlib.pyplot as pltimport numpy as npimport scipy.constants as const#-----------------------------------------#   Local packages#-----------------------------------------# local packages and modulesfrom potential import D1from system import systemfrom integrator import D1_stochastic#-----------------------------------------#  Set system parameters#-----------------------------------------m = 1       # massx0 = 0.0    # initial positionv0 = 0.0    # initial velocityT = 300     # temperaturexi = 50     # friction dt = 0.1    # time steph = 0.001   # discretization interval#-----------------------------------------#  Set potential parameters#-----------------------------------------k = 1a = 0b = 1#-----------------------------------------#  Set simulation paramters#-----------------------------------------# number of time stepsnsteps = 1_000_000# recording frequencynstout = 10# resulting trajectory sizetraj_size = int(nsteps/nstout)# number of trajectoriesntraj = 10#%% Initializing system# initialize systemprint("---------------------------------------")print("Initializing system:")this_system = system.D1(m, x0, v0 , T, xi, dt, h)print(" ")print("system parameters:")print("m: ",  this_system.m)print("x0: ",  this_system.x)print("v0: ",  this_system.v)print("T: ",  this_system.T)print("xi: ",  this_system.xi)print("dt: ",  this_system.dt)print("h: ",  this_system.h)print(" ")print("combined system parameters:")print("xi * m : ",  this_system.xi_m)print("D: ",  this_system.D)print("sigma: ",  this_system.sigma)#%% Initializing  potentialprint(" ")print("---------------------------------------")print(" Initializing  potential: D1.DoubleWell ") param = [k, a, b]this_potential = D1.DoubleWell(param)print(" ")print("potential parameters")print("k: ",  this_potential.k)print("a: ",  this_potential.a)print("b: ",  this_potential.b)#%% Simulation with EM integrator: sampling the potentialprint(" ")print("---------------------------------------")print(" Simulation with EM integrator: sampling the potential ")print(" ")print("simulation parameters:")print("number of timesteps: ",  nsteps)print("recording frequency: ",  nstout)print("trajectory size: ",  traj_size)print("number of trajectories: ",  ntraj)# initialize array of trajectoriestraj_x = np.zeros( (traj_size+1) * ntraj ).reshape((traj_size+1), ntraj)# loop over trajectoriesfor traj in range(ntraj):     print(" ")    print("--------------")    print("trajectory", traj+1)        # set initial position and velocity to trajectory    traj_x[0, traj] = this_system.x        # run the simulation    # time index of the trajectory    traj_t = 0    # progress counter    progress = 0    for t in range(nsteps):             # EM integration step        D1_stochastic.EM(this_system, this_potential)            # record update position and velocity        if t%nstout == 0:            traj_t +=1            traj_x[traj_t, traj] = this_system.x            if t%(nsteps/10) == 0:            progress += 10            print(progress, "%")#%% Plotting  the potentialprint(" ")print("---------------------------------------")print(" Plotting  the potential  ")# set x-axisx = np.linspace(-2, 2, 201)    # plotplt.figure(figsize=(12, 6)) color = plt.cm.viridis( 0)  # Normalize a to be in [0, 1]plt.plot(x, this_potential.potential(x) , color=color, label = "Simulation potential")    plt.grid()plt.ylim(0,2)plt.xlabel("x")plt.ylabel("V(x)") plt.title("Simulation potential: double well")#plt.legend()plt.show()   plt.close()#%% Analyze trajectory: Stationary distribution of the positionsprint(" ")print("---------------------------------------")print(" Plotting  the stationary distribution  ")# start and end point of the histogramx_min = -2.5x_max = +2.5nbins = 50# initialize array of sampled histrogramsx_hist = np.zeros(nbins * ntraj).reshape(nbins, ntraj)x_hist_norm = np.zeros(nbins * ntraj).reshape(nbins, ntraj)for traj in range(ntraj):    # sampled distribution    x_hist[:,traj], x_edges = np.histogram(traj_x[:,traj], np.linspace(x_min, x_max, nbins+1) )# get bin centerx_centers = (x_edges[:-1] + x_edges[1:]) / 2# get Delta xx_Delta = x_edges[1] - x_edges[0]# normalize histogramfor traj in range(ntraj):    x_hist_norm[:,traj] = x_hist[:,traj]/np.sum(x_hist[:,traj]) * x_Delta# analytical distributionbeta = 1 / (this_system.T * const.R * 0.001)x_Boltzmann = np.exp(- beta * this_potential.potential(x_centers) )x_Boltzmann = x_Boltzmann / np.sum(x_Boltzmann) * x_Delta# plot analytical and sampled distributionsplt.figure(figsize=(12, 6)) # loop over the sampled distributionsfor traj in range(ntraj):    color = plt.cm.viridis(traj / ntraj)  # Normalize a to be in [0, 1]    plt.plot(x_centers, x_hist_norm[:,traj] , color=color, linestyle = "dashed", label ='traj {:.0f}'.format(traj+1))# now plot the analytical distribution on topcolor = "black"  # Normalize a to be in [0, 1]plt.plot(x_centers, x_Boltzmann , color=color, label = "Boltzmann distribution")plt.grid()plt.ylim(0,0.005)plt.xlabel("x [nm]")plt.ylabel("p(x)") plt.title("Sampled distribution: positions")plt.legend()plt.show()   plt.close()print(" ")print("---------------------------------------")print("END")print("---------------------------------------")